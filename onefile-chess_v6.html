<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        .game-over-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            text-align: center;
        }
        
        .game-over-content {
            background-color: #2c3e50;
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
        }
        
        /* Final position board (mini board) */
        #final-position {
            display: grid;
            grid-template-columns: repeat(8, 25px);
            grid-template-rows: repeat(8, 25px);
            margin: 20px auto;
            border: 2px solid #555;
            width: 200px;
            height: 200px;
        }
        
        .mini-square {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .mini-square.light {
            background-color: #f0d9b5;
        }
        
        .mini-square.dark {
            background-color: #b58863;
        }
        
        .mini-piece {
            width: 22px;
            height: 22px;
            z-index: 1;
        }
        
        /* Mini notation table for game over modal */
        .mini-notation-table {
            margin: 0 auto;
            border-collapse: collapse;
            width: 80%;
            max-height: 200px;
            overflow-y: auto;
            font-size: 12px;
        }
        
        .mini-notation-table th,
        .mini-notation-table td {
            padding: 3px 5px;
            text-align: center;
            border: 1px solid #555;
        }
        
        .mini-notation-table th {
            background-color: #34495e;
            color: white;
        }
        
        .mini-notation-table tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        /* Chess Clock Styles */
        .chess-clock {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            width: 100%;
        }
        
        .clock {
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 24px;
            font-weight: bold;
            width: 48%;
            text-align: center;
            background-color: #2c3e50;
            color: white;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .clock {
            /* Reset text color for both clocks */
            color: #000;
        }
        
        .clock.active {
            border-color: #27ae60;
            box-shadow: 0 0 15px rgba(39, 174, 96, 0.5);
        }
        
        .clock.warning {
            color: #e74c3c;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 5px rgba(231, 76, 60, 0.5); }
            50% { box-shadow: 0 0 20px rgba(231, 76, 60, 0.8); }
            100% { box-shadow: 0 0 5px rgba(231, 76, 60, 0.5); }
        }
        
        .game-over-title {
            font-size: 32px;
            margin-bottom: 20px;
            color: gold;
        }
        
        .game-over-message {
            font-size: 18px;
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .game-over-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        
        h1 {
            margin-bottom: 20px;
            color: #333;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            padding: 20px;
            max-width: 100%;
        }
        
        .game-info {
            margin-bottom: 15px;
            font-size: 18px;
            width: 100%;
            text-align: center;
            padding: 10px;
            border-radius: 5px;
            background-color: #f5f5f5;
        }
        
        .game-status {
            font-weight: bold;
            color: #333;
        }
        
        .check-status {
            color: red;
            font-weight: bold;
        }
        
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: min(80vw, 560px);
            height: min(80vw, 560px);
            border: 3px solid #333;
            position: relative;
        }
        
        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            user-select: none;
        }
        
        /* Board Themes */
        /* Classic Theme (Default) */
        .white {
            background-color: #f0d9b5;
        }
        
        .black {
            background-color: #b58863;
        }
        
        /* Wood Theme */
        .wood .white {
            background-color: #E8C99B;
        }
        
        .wood .black {
            background-color: #9A6017;
        }
        
        /* Blue Theme */
        .blue .white {
            background-color: #E6EEF8;
        }
        
        .blue .black {
            background-color: #5B8FBC;
        }
        
        /* Green Theme */
        .green .white {
            background-color: #E8F2E3;
        }
        
        .green .black {
            background-color: #548F55;
        }
        
        /* Theme Selector Styles */
        .theme-selector {
            margin-top: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .theme-selector label {
            font-weight: bold;
        }
        
        .theme-selector select {
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
        }
        
        .notation {
            position: absolute;
            font-size: 12px;
            color: rgba(0, 0, 0, 0.5);
        }
        
        .file-notation {
            bottom: 2px;
            right: 2px;
        }
        
        .rank-notation {
            top: 2px;
            left: 2px;
        }
        
        .piece {
            width: 80%;
            height: 80%;
            cursor: grab;
            position: relative;
            z-index: 2;
            transition: transform 0.15s ease;
            user-select: none;
            -webkit-user-drag: none;
        }
        
        .piece:hover {
            transform: scale(1.1);
        }
        
        .piece.dragging {
            position: fixed; /* Fixed position for better dragging */
            pointer-events: none;
            z-index: 1000;
            opacity: 0.95; /* Highly visible */
            transform: scale(1.2);
            transition: none; /* Remove transition for immediate response */
            filter: drop-shadow(0px 5px 5px rgba(0,0,0,0.5)); /* Add shadow for better visibility */
            cursor: grabbing; /* Show grabbing cursor */
            will-change: left, top; /* Optimize for animations */
            margin: 0; /* Reset margins to ensure proper positioning */
            padding: 0; /* Reset padding */
        }
        
        .highlight {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        .valid-move {
            background-color: rgba(0, 255, 0, 0.3);
        }
        
        .selected {
            background-color: rgba(255, 255, 0, 0.4);
        }
        
        .check {
            background-color: rgba(255, 0, 0, 0.4);
        }
        
        .last-move {
            background-color: rgba(173, 216, 230, 0.5);
        }
        
        .captured-pieces {
            display: flex;
            flex-wrap: wrap;
            margin-top: 15px;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
            max-width: min(80vw, 560px);
        }
        
        .captured-pieces div {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 10px;
        }
        
        .captured-pieces h3 {
            margin-bottom: 5px;
        }
        
        .captured-pieces-list {
            display: flex;
            flex-wrap: wrap;
        }
        
        .captured-piece {
            width: 30px;
            height: 30px;
            margin: 2px;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 10px 15px;
            background-color: #4a6ea9;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #3a5a89;
        }
        
        .promotion-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 10;
            justify-content: center;
            align-items: center;
        }
        
        .promotion-options {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .promotion-options h2 {
            margin-bottom: 15px;
        }
        
        .promotion-pieces {
            display: flex;
            gap: 15px;
        }
        
        .promotion-piece {
            width: 60px;
            height: 60px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
        }
        
        .promotion-piece:hover {
            background-color: #e0e0e0;
        }
        
        /* Chess Clock styles */
        .chess-clock {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            max-width: 560px;
            gap: 20px;
        }
        
        .clock {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 20px;
            background-color: #f5f5f5;
            border-radius: 5px;
            flex-grow: 1;
            border: 2px solid transparent;
        }
        
        .clock.active {
            border-color: #4a6ea9;
            background-color: #e9eff8;
        }
        
        .clock.warning {
            color: #c00;
        }
        
        .clock-label {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .clock-time {
            font-size: 24px;
            font-family: monospace;
        }
        
        /* Notation Table styles */
        .game-layout {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .notation-container {
            flex-grow: 1;
            max-width: 300px;
            min-width: 200px;
        }
        
        .notation-container h3 {
            margin-top: 0;
            margin-bottom: 10px;
        }
        
        .notation-table-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        
        .notation-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .notation-table th, .notation-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        
        .notation-table th {
            background-color: #f2f2f2;
            position: sticky;
            top: 0;
        }
        
        .notation-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .notation-table tr:hover {
            background-color: #f0f0f0;
        }
        
        .notation-table td.latest-move {
            background-color: #e1f5fe;
            font-weight: bold;
            position: relative;
        }
        
        .notation-table td.latest-move::before {
            content: "»";
            position: absolute;
            left: 3px;
            color: #0277bd;
        }
        
        .notation-table td.current-turn {
            background-color: #e8f5e9;
            font-style: italic;
            position: relative;
        }
        
        .notation-table td.current-turn::before {
            content: "•";
            position: absolute;
            right: 5px;
            color: #2e7d32;
        }
        
        /* Position Review in Game Over */
        .position-review {
            margin-top: 15px;
            text-align: center;
        }
        
        .mini-board {
            margin: 0 auto;
            width: 240px;
            height: 240px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 2px solid #333;
        }
        
        .mini-square {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
        }
        
        .mini-square.light {
            background-color: #f0d9b5;
        }
        
        .mini-square.dark {
            background-color: #b58863;
        }
        
        .mini-piece {
            width: 25px;
            height: 25px;
        }
        
        @media (max-width: 600px) {
            .chessboard {
                width: 95vw;
                height: 95vw;
            }
            
            .game-container {
                padding: 10px;
            }
            
            .notation {
                font-size: 10px;
            }
            
            .captured-piece {
                width: 20px;
                height: 20px;
            }
            
            .promotion-piece {
                width: 50px;
                height: 50px;
            }
            
            .game-layout {
                flex-direction: column;
            }
            
            .notation-container {
                max-width: 100%;
            }
            
            .clock-time {
                font-size: 20px;
            }
            
            .mini-board {
                width: 200px;
                height: 200px;
            }
            
            .mini-square {
                width: 25px;
                height: 25px;
            }
            
            .mini-piece {
                width: 20px;
                height: 20px;
            }
        }
    </style>
</head>
<body>
    <h1>Chess Game</h1>
    
    <div class="game-container">
        <div class="game-info">
            <span class="game-status">Current Turn: White</span>
            <span class="check-status"></span>
        </div>
        
        <div class="chess-clock">
            <div class="clock white-clock">
                <span class="clock-label">White</span>
                <span class="clock-time" id="white-time">10:00</span>
            </div>
            <div class="clock black-clock">
                <span class="clock-label">Black</span>
                <span class="clock-time" id="black-time">10:00</span>
            </div>
        </div>
        
        <div class="game-layout">
            <div class="chessboard" id="chessboard"></div>
            
            <div class="notation-container">
                <h3>Move History</h3>
                <div class="notation-table-container">
                    <table class="notation-table" id="notation-table">
                        <thead>
                            <tr>
                                <th>Move</th>
                                <th>White</th>
                                <th>Black</th>
                            </tr>
                        </thead>
                        <tbody id="notation-body">
                            <!-- Move notation will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <div class="captured-pieces">
            <div>
                <h3>Captured White Pieces</h3>
                <div class="captured-pieces-list" id="captured-white"></div>
            </div>
            <div>
                <h3>Captured Black Pieces</h3>
                <div class="captured-pieces-list" id="captured-black"></div>
            </div>
        </div>
        
        <div class="controls">
            <button id="reset-game">New Game</button>
            <button id="undo-move">Undo Move</button>
            <button id="play-computer">Make this a computer player</button>
            <select id="computer-difficulty">
                <option value="easy">Easy</option>
                <option value="medium">Medium</option>
            </select>
        </div>
        
        <div class="theme-selector">
            <label for="board-theme">Board Theme:</label>
            <select id="board-theme">
                <option value="classic">Classic</option>
                <option value="wood">Wood</option>
                <option value="blue">Blue</option>
                <option value="green">Green</option>
            </select>
        </div>
    </div>
    
    <div class="promotion-modal" id="promotion-modal">
        <div class="promotion-options">
            <h2>Choose promotion piece</h2>
            <div class="promotion-pieces" id="promotion-pieces"></div>
        </div>
    </div>
    
    <div class="game-over-container" id="game-over-modal">
        <div class="game-over-content">
            <h2 class="game-over-title">Game Over</h2>
            <p class="game-over-message" id="game-over-message">Checkmate! Player has won the game.</p>
            
            <div class="position-review">
                <h3>Final Position</h3>
                <div id="final-position"></div>
            </div>
            
            <div class="notation-review">
                <h3>Move History</h3>
                <div id="notation-summary"></div>
            </div>
            
            <div class="game-over-buttons">
                <button id="new-game-btn">New Game</button>
            </div>
        </div>
    </div>

    <script>
        // SVG Definitions for chess pieces
        const pieceSVGs = {
            'white-pawn': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><path d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z" fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round"/></svg>',
            'black-pawn': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><path d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z" fill="#000" stroke="#000" stroke-width="1.5" stroke-linecap="round"/></svg>',
            'white-rook': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><g fill="#fff" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5" stroke-linecap="butt"/><path d="M34 14l-3 3H14l-3-3"/><path d="M31 17v12.5H14V17" stroke-linecap="butt" stroke-linejoin="miter"/><path d="M31 29.5l1.5 2.5h-20l1.5-2.5"/><path d="M11 14h23" fill="none" stroke-linejoin="miter"/></g></svg>',
            'black-rook': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><g fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M9 39h27v-3H9v3zM12.5 32l1.5-2.5h17l1.5 2.5h-20zM12 36v-4h21v4H12z" stroke-linecap="butt"/><path d="M14 29.5v-13h17v13H14z" stroke-linecap="butt" stroke-linejoin="miter"/><path d="M14 16.5L11 14h23l-3 2.5H14zM11 14V9h4v2h5V9h5v2h5V9h4v5H11z" stroke-linecap="butt"/><path d="M12 35.5h21M13 31.5h19M14 29.5h17M14 16.5h17M11 14h23" fill="none" stroke-linejoin="miter" stroke-width="1"/></g></svg>',
            'white-knight': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><g fill="none" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21" fill="#fff"/><path d="M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-4 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3" fill="#fff"/><path d="M9.5 25.5a.5.5 0 1 1-1 0 .5.5 0 1 1 1 0zm5.433-9.75a.5 1.5 30 1 1-.866-.5.5 1.5 30 1 1 .866.5z" fill="#000"/></g></svg>',
            'black-knight': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><g fill="none" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21" fill="#000"/><path d="M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-4 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3" fill="#000"/><path d="M9.5 25.5a.5.5 0 1 1-1 0 .5.5 0 1 1 1 0zm5.433-9.75a.5 1.5 30 1 1-.866-.5.5 1.5 30 1 1 .866.5z" fill="#fff" stroke="#fff"/><path d="M24.55 10.4l-.45 1.45.5.15c3.15 1 5.65 2.49 7.9 6.75S35.75 29.06 35.25 39l-.05.5h2.25l.05-.5c.5-10.06-.88-16.85-3.25-21.34-2.37-4.49-5.79-6.64-9.19-7.16l-.51-.1z" fill="#fff" stroke="none"/></g></svg>',
            'white-bishop': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><g fill="none" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><g fill="#fff" stroke-linecap="butt"><path d="M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.354.49-2.323.47-3-.5 1.354-1.94 3-2 3-2z"/><path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/><path d="M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z"/></g><path d="M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5" stroke-linejoin="miter"/></g></svg>',
            'black-bishop': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><g fill="none" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><g fill="#000" stroke-linecap="butt"><path d="M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.354.49-2.323.47-3-.5 1.354-1.94 3-2 3-2z"/><path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/><path d="M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z"/></g><path d="M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5" stroke="#fff" stroke-linejoin="miter"/></g></svg>',
            'white-queen': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><g fill="#fff" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><g><circle cx="6" cy="12" r="2.75" fill="#fff" stroke="#000"/><circle cx="14" cy="9" r="2.75" fill="#fff" stroke="#000"/><circle cx="22.5" cy="8" r="2.75" fill="#fff" stroke="#000"/><circle cx="31" cy="9" r="2.75" fill="#fff" stroke="#000"/><circle cx="39" cy="12" r="2.75" fill="#fff" stroke="#000"/></g><path d="M9 26c8.5-1.5 21-1.5 27 0l2.5-12.5L31 25l-.3-14.1-5.2 13.6-3-14.5-3 14.5-5.2-13.6L14 25 6.5 13.5 9 26z" stroke-linecap="butt"/><path d="M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1.5 2.5-1.5 2.5-1.5 1.5.5 2.5.5 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z" stroke-linecap="butt"/><path d="M11 38.5a35 35 1 0 0 23 0" fill="none" stroke-linecap="butt"/><path d="M11 29a35 35 1 0 1 23 0m-21.5 2.5h20m-21 3a35 35 1 0 0 22 0m-23 3a35 35 1 0 0 24 0" fill="none" stroke="#000"/></g></svg>',
            'black-queen': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><g fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><g stroke="none"><circle cx="6" cy="12" r="2.75"/><circle cx="14" cy="9" r="2.75"/><circle cx="22.5" cy="8" r="2.75"/><circle cx="31" cy="9" r="2.75"/><circle cx="39" cy="12" r="2.75"/></g><path d="M9 26c8.5-1.5 21-1.5 27 0l2.5-12.5L31 25l-.3-14.1-5.2 13.6-3-14.5-3 14.5-5.2-13.6L14 25 6.5 13.5 9 26z" stroke-linecap="butt"/><path d="M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1.5 2.5-1.5 2.5-1.5 1.5.5 2.5.5 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z" stroke-linecap="butt"/><path d="M11 38.5a35 35 1 0 0 23 0" fill="none" stroke-linecap="butt"/><path d="M11 29a35 35 1 0 1 23 0m-21.5 2.5h20m-21 3a35 35 1 0 0 22 0m-23 3a35 35 1 0 0 24 0" fill="none" stroke="#fff"/></g></svg>',
            'white-king': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><g fill="none" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22.5 11.63V6M20 8h5" stroke-linejoin="miter"/><path d="M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5" fill="#fff" stroke-linecap="butt" stroke-linejoin="miter"/><path d="M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-3.5-7.5-13-10.5-16-4-3 6 5 10 5 10V37z" fill="#fff"/><path d="M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0"/></g></svg>',
            'black-king': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><g fill="none" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22.5 11.63V6" stroke-linejoin="miter"/><path d="M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5" fill="#000" stroke-linecap="butt" stroke-linejoin="miter"/><path d="M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-3.5-7.5-13-10.5-16-4-3 6 5 10 5 10V37z" fill="#000"/><path d="M20 8h5" stroke-linejoin="miter"/><path d="M32 29.5s8.5-4 6.03-9.65C34.15 14 25 18 22.5 24.5l.01 2.1-.01-2.1C20 18 9.906 14 6.997 19.85c-2.497 5.65 4.853 9 4.853 9M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0" stroke="#fff"/></g></svg>'
        };

        // Chess game implementation
        document.addEventListener('DOMContentLoaded', function() {
            // DOM elements
            const chessboard = document.getElementById('chessboard');
            const gameStatus = document.querySelector('.game-status');
            const checkStatus = document.querySelector('.check-status');
            const resetButton = document.getElementById('reset-game');
            const undoButton = document.getElementById('undo-move');
            const capturedWhite = document.getElementById('captured-white');
            const capturedBlack = document.getElementById('captured-black');
            const promotionModal = document.getElementById('promotion-modal');
            const promotionPieces = document.getElementById('promotion-pieces');
            const gameOverModal = document.getElementById('game-over-modal');
            const gameOverMessage = document.getElementById('game-over-message');
            const newGameBtn = document.getElementById('new-game-btn');
            const whiteTime = document.getElementById('white-time');
            const blackTime = document.getElementById('black-time');
            const notationBody = document.getElementById('notation-body');
            const finalPositionBoard = document.getElementById('final-position-board');
            
            // Game state
            let board = [];
            let currentPlayer = 'white';
            let selectedPiece = null;
            let validMoves = [];
            let gameHistory = [];
            let capturedPieces = { white: [], black: [] };
            let kings = { white: null, black: null };
            let inCheck = { white: false, black: false };
            let lastMove = { from: null, to: null };
            let waitingForPromotion = null;
            let isComputerGame = false;
            let computerColor = 'black';
            let computerDifficulty = 'easy';
            
            // Chess clock state
            const INITIAL_TIME = 10 * 60; // 10 minutes in seconds
            let times = { white: INITIAL_TIME, black: INITIAL_TIME };
            let clockInterval = null;
            let clockRunning = false;
            let gameStarted = false; // Track if New Game has been clicked
            let clockNeedsReset = true; // Track if the clock needs to be reset
            
            // Notation state
            let moveCount = 1;
            let moveNotation = [];
            
            // Chess piece class for modeling the pieces
            class ChessPiece {
                constructor(type, color, position) {
                    this.type = type;
                    this.color = color;
                    this.position = position;
                    this.hasMoved = false;
                }
                
                getValidMoves(board) {
                    const moves = [];
                    const [row, col] = this.position;
                    
                    switch(this.type) {
                        case 'pawn':
                            this.getPawnMoves(board, moves, row, col);
                            break;
                        case 'rook':
                            this.getStraightMoves(board, moves, row, col);
                            break;
                        case 'knight':
                            this.getKnightMoves(board, moves, row, col);
                            break;
                        case 'bishop':
                            this.getDiagonalMoves(board, moves, row, col);
                            break;
                        case 'queen':
                            this.getStraightMoves(board, moves, row, col);
                            this.getDiagonalMoves(board, moves, row, col);
                            break;
                        case 'king':
                            this.getKingMoves(board, moves, row, col);
                            break;
                    }
                    
                    // Filter out moves that would put or leave the king in check
                    return moves.filter(move => !wouldKingBeInCheck(this, move, board));
                }
                
                getPawnMoves(board, moves, row, col) {
                    const direction = this.color === 'white' ? -1 : 1;
                    const startRow = this.color === 'white' ? 6 : 1;
                    
                    // Move forward one square
                    if (isInBounds(row + direction, col) && !board[row + direction][col]) {
                        moves.push([row + direction, col]);
                        
                        // Move forward two squares from starting position
                        if (row === startRow && !board[row + 2 * direction][col]) {
                            moves.push([row + 2 * direction, col]);
                        }
                    }
                    
                    // Capture diagonally
                    for (const dc of [-1, 1]) {
                        if (isInBounds(row + direction, col + dc)) {
                            const targetPiece = board[row + direction][col + dc];
                            if (targetPiece && targetPiece.color !== this.color) {
                                moves.push([row + direction, col + dc]);
                            }
                            
                            // En passant
                            if (lastMove.from && lastMove.to) {
                                const [fromRow, fromCol] = lastMove.from;
                                const [toRow, toCol] = lastMove.to;
                                const lastPiece = board[toRow][toCol];
                                
                                if (lastPiece && 
                                    lastPiece.type === 'pawn' && 
                                    lastPiece.color !== this.color && 
                                    Math.abs(fromRow - toRow) === 2 && 
                                    toRow === row && 
                                    toCol === col + dc) {
                                    moves.push([row + direction, col + dc, 'en-passant']);
                                }
                            }
                        }
                    }
                }
                
                getStraightMoves(board, moves, row, col) {
                    // Horizontal and vertical directions
                    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    
                    for (const [dr, dc] of directions) {
                        let r = row + dr;
                        let c = col + dc;
                        
                        while (isInBounds(r, c)) {
                            if (!board[r][c]) {
                                moves.push([r, c]);
                            } else {
                                if (board[r][c].color !== this.color) {
                                    moves.push([r, c]);
                                }
                                break;
                            }
                            r += dr;
                            c += dc;
                        }
                    }
                }
                
                getDiagonalMoves(board, moves, row, col) {
                    // Diagonal directions
                    const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                    
                    for (const [dr, dc] of directions) {
                        let r = row + dr;
                        let c = col + dc;
                        
                        while (isInBounds(r, c)) {
                            if (!board[r][c]) {
                                moves.push([r, c]);
                            } else {
                                if (board[r][c].color !== this.color) {
                                    moves.push([r, c]);
                                }
                                break;
                            }
                            r += dr;
                            c += dc;
                        }
                    }
                }
                
                getKnightMoves(board, moves, row, col) {
                    const knightMoves = [
                        [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                        [1, -2], [1, 2], [2, -1], [2, 1]
                    ];
                    
                    for (const [dr, dc] of knightMoves) {
                        const r = row + dr;
                        const c = col + dc;
                        
                        if (isInBounds(r, c) && (!board[r][c] || board[r][c].color !== this.color)) {
                            moves.push([r, c]);
                        }
                    }
                }
                
                getKingMoves(board, moves, row, col) {
                    // All 8 directions
                    const kingMoves = [
                        [-1, -1], [-1, 0], [-1, 1],
                        [0, -1],           [0, 1],
                        [1, -1],  [1, 0],  [1, 1]
                    ];
                    
                    for (const [dr, dc] of kingMoves) {
                        const r = row + dr;
                        const c = col + dc;
                        
                        if (isInBounds(r, c) && (!board[r][c] || board[r][c].color !== this.color)) {
                            // Create a deep copy of the board for move simulation
                            const tempBoard = Array(8).fill().map(() => Array(8).fill(null));
                            for (let i = 0; i < 8; i++) {
                                for (let j = 0; j < 8; j++) {
                                    if (board[i][j]) {
                                        tempBoard[i][j] = new ChessPiece(
                                            board[i][j].type,
                                            board[i][j].color,
                                            [...board[i][j].position]
                                        );
                                        tempBoard[i][j].hasMoved = board[i][j].hasMoved;
                                    }
                                }
                            }
                            
                            // Move the king on the temporary board
                            tempBoard[r][c] = tempBoard[row][col];
                            tempBoard[row][col] = null;
                            if (tempBoard[r][c]) {  // Safety check
                                tempBoard[r][c].position = [r, c];
                                
                                // Only add the move if the destination square is not under attack
                                if (!isSquareAttacked(r, c, tempBoard, this.color)) {
                                    moves.push([r, c]);
                                }
                            }
                        }
                    }
                    
                    // Castling
                    if (!this.hasMoved && !inCheck[this.color]) {
                        // Kingside castling
                        let canCastleKingside = true;
                        for (let c = col + 1; c < 7; c++) {
                            if (board[row][c]) {
                                canCastleKingside = false;
                                break;
                            }
                        }
                        
                        const kingsideRook = board[row][7];
                        if (canCastleKingside && kingsideRook && 
                            kingsideRook.type === 'rook' && 
                            kingsideRook.color === this.color && 
                            !kingsideRook.hasMoved) {
                            // Check if king passes through check
                            if (!isSquareAttacked(row, col + 1, board, this.color) && 
                                !isSquareAttacked(row, col + 2, board, this.color)) {
                                moves.push([row, col + 2, 'castle-kingside']);
                            }
                        }
                        
                        // Queenside castling
                        let canCastleQueenside = true;
                        for (let c = col - 1; c > 0; c--) {
                            if (board[row][c]) {
                                canCastleQueenside = false;
                                break;
                            }
                        }
                        
                        const queensideRook = board[row][0];
                        if (canCastleQueenside && queensideRook && 
                            queensideRook.type === 'rook' && 
                            queensideRook.color === this.color && 
                            !queensideRook.hasMoved) {
                            // Check if king passes through check
                            if (!isSquareAttacked(row, col - 1, board, this.color) && 
                                !isSquareAttacked(row, col - 2, board, this.color)) {
                                moves.push([row, col - 2, 'castle-queenside']);
                            }
                        }
                    }
                }
            }
            
            // Utility functions
            function isInBounds(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }
            
            function wouldKingBeInCheck(piece, move, currentBoard) {
                // Create a proper deep copy of the board for simulation
                const tempBoard = Array(8).fill().map(() => Array(8).fill(null));
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        if (currentBoard[i][j]) {
                            // Create a new piece with the same properties
                            tempBoard[i][j] = new ChessPiece(
                                currentBoard[i][j].type,
                                currentBoard[i][j].color,
                                [...currentBoard[i][j].position]
                            );
                            tempBoard[i][j].hasMoved = currentBoard[i][j].hasMoved;
                        }
                    }
                }
                
                const [fromRow, fromCol] = piece.position;
                const [toRow, toCol] = move;
                
                // Special case for en passant
                if (move.length > 2 && move[2] === 'en-passant') {
                    const capturedPawnRow = fromRow;
                    const capturedPawnCol = toCol;
                    tempBoard[capturedPawnRow][capturedPawnCol] = null;
                }
                
                // Move the piece on the temporary board
                tempBoard[toRow][toCol] = tempBoard[fromRow][fromCol];
                if (tempBoard[toRow][toCol]) {
                    tempBoard[toRow][toCol].position = [toRow, toCol];
                }
                tempBoard[fromRow][fromCol] = null;
                
                // Find the king's position
                let kingPos = null;
                if (piece.type === 'king') {
                    kingPos = [toRow, toCol];
                } else {
                    // Find the king on the board
                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c < 8; c++) {
                            const p = tempBoard[r][c];
                            if (p && p.type === 'king' && p.color === piece.color) {
                                kingPos = [r, c];
                                break;
                            }
                        }
                        if (kingPos) break;
                    }
                }
                
                // If no king is found, assume the move is valid (this shouldn't happen in a normal game)
                if (!kingPos) {
                    console.log("Warning: No king found when simulating move. This shouldn't happen.");
                    return false;
                }
                
                // Check if the king would be in check after the move
                const wouldBeInCheck = isSquareAttacked(kingPos[0], kingPos[1], tempBoard, piece.color);
                
                if (wouldBeInCheck) {
                    console.log(`Move [${fromRow},${fromCol}] to [${toRow},${toCol}] would leave ${piece.color} king in check`);
                }
                
                return wouldBeInCheck;
            }
            
            function isSquareAttacked(row, col, board, color) {
                // Safety check - if row or col is undefined, return false
                if (row === undefined || col === undefined) {
                    console.log(`isSquareAttacked called with undefined coordinates for ${color} king`);
                    return false;
                }
                
                console.log(`Checking if ${color} king at [${row},${col}] is under attack`);
                
                // Check for attacks from pawns
                // For a king of color 'white', we need to check if there are black pawns that can attack
                // Black pawns move down the board, so they would be at [row-1, col±1]
                // For a king of color 'black', we need to check if there are white pawns that can attack
                // White pawns move up the board, so they would be at [row+1, col±1]
                
                // Pawns attack in the opposite direction from their movement
                const pawnAttackDirection = color === 'white' ? -1 : 1;
                for (const dc of [-1, 1]) {
                    const r = row + pawnAttackDirection;
                    const c = col + dc;
                    if (isInBounds(r, c) && board[r][c] && 
                        board[r][c].type === 'pawn' && 
                        board[r][c].color !== color) {
                        console.log(`King at [${row},${col}] is under attack by pawn at [${r},${c}]`);
                        return true;
                    }
                }
                
                // Check for attacks from knights
                const knightMoves = [
                    [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                    [1, -2], [1, 2], [2, -1], [2, 1]
                ];
                
                for (const [dr, dc] of knightMoves) {
                    const r = row + dr;
                    const c = col + dc;
                    if (isInBounds(r, c) && board[r][c] && 
                        board[r][c].type === 'knight' && 
                        board[r][c].color !== color) {
                        console.log(`King at [${row},${col}] is under attack by knight at [${r},${c}]`);
                        return true;
                    }
                }
                
                // Check for attacks from bishops, rooks, queens, and kings along straight lines
                const directions = [
                    [-1, 0], [1, 0], [0, -1], [0, 1], // Rook/Queen directions (vertical/horizontal)
                    [-1, -1], [-1, 1], [1, -1], [1, 1] // Bishop/Queen directions (diagonal)
                ];
                
                for (const [dr, dc] of directions) {
                    let r = row + dr;
                    let c = col + dc;
                    let distance = 1;
                    
                    while (isInBounds(r, c)) {
                        if (board[r][c]) {
                            const piece = board[r][c];
                            if (piece.color !== color) {
                                // Horizontal or vertical direction (straight lines)
                                const isStraightLine = Math.abs(dr * dc) === 0;
                                // Diagonal direction
                                const isDiagonal = Math.abs(dr * dc) === 1;
                                
                                if ((piece.type === 'queen') || 
                                    (piece.type === 'rook' && isStraightLine) || 
                                    (piece.type === 'bishop' && isDiagonal) || 
                                    (piece.type === 'king' && distance === 1)) {
                                    console.log(`King at [${row},${col}] is under attack by ${piece.type} at [${r},${c}]`);
                                    return true;
                                }
                            }
                            break; // Stop in this direction if we hit any piece
                        }
                        r += dr;
                        c += dc;
                        distance++;
                    }
                }
                
                console.log(`King at [${row},${col}] is NOT under attack`);
                return false;
            }
            
            // Chess Clock Functions
            function startClock() {
                // Only start the clock if a game has been started
                if (gameStarted && !clockRunning) {
                    console.log("Starting the clock...");
                    if (clockNeedsReset) {
                        times = { white: INITIAL_TIME, black: INITIAL_TIME };
                        clockNeedsReset = false;
                    }
                    updateClockDisplay();
                    clockInterval = setInterval(updateClock, 1000);
                    clockRunning = true;
                } else {
                    console.log("Clock not started - gameStarted: " + gameStarted + ", clockRunning: " + clockRunning);
                }
                
                updateActiveClockUI();
            }
            
            function stopClock() {
                if (clockRunning) {
                    clearInterval(clockInterval);
                    clockInterval = null;
                    clockRunning = false;
                }
            }
            
            function updateClock() {
                if (times[currentPlayer] <= 0) {
                    // Time's up
                    times[currentPlayer] = 0;
                    stopClock();
                    const winner = currentPlayer === 'white' ? 'Black' : 'White';
                    showGameOver(`Time's up! ${winner} wins on time.`);
                } else {
                    times[currentPlayer]--;
                    
                    // Add warning class when time is getting low (less than 1 minute)
                    if (times[currentPlayer] < 60) {
                        document.querySelector(`.${currentPlayer}-clock`).classList.add('warning');
                    }
                }
                
                updateClockDisplay();
            }
            
            function updateClockDisplay() {
                whiteTime.textContent = formatTime(times.white);
                blackTime.textContent = formatTime(times.black);
            }
            
            function formatTime(seconds) {
                const minutes = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            
            function updateActiveClockUI() {
                document.querySelector('.white-clock').classList.toggle('active', currentPlayer === 'white');
                document.querySelector('.black-clock').classList.toggle('active', currentPlayer === 'black');
            }
            
            function resetClock() {
                // First, ensure we stop any existing clock
                stopClock();
                
                // Reset times to initial values
                times = { white: INITIAL_TIME, black: INITIAL_TIME };
                
                // Update the clock display to show the reset times
                updateClockDisplay();
                
                // Remove any warning states from the clocks
                document.querySelector('.white-clock').classList.remove('warning');
                document.querySelector('.black-clock').classList.remove('warning');
                
                // Log the game state for debugging
                console.log("Reset clock - gameStarted: " + gameStarted);
                
                // Reset the active clock highlighting
                updateActiveClockUI();
                
                // We don't automatically start the clock here - this is handled separately
                // by the caller functions (New Game button, Play vs Computer)
                
                // Reset the flag for future clock starts
                clockNeedsReset = false;
                
                // If the game has started, we should ensure the clock is ready to run
                if (gameStarted) {
                    // Prepare for clock to start (will be started by caller if needed)
                    document.querySelector('.white-clock').classList.add('active');
                    document.querySelector('.black-clock').classList.remove('active');
                }
            }
            
            // Chess Notation Functions
            function getNotation(piece, fromRow, fromCol, toRow, toCol, isCapture, isCheck, isCheckmate, isPromotion, promotionPiece, isCastle) {
                let notation = '';
                
                // Special notation for castling
                if (isCastle) {
                    if (toCol === 6) { // Kingside
                        notation = 'O-O';
                    } else if (toCol === 2) { // Queenside
                        notation = 'O-O-O';
                    }
                    
                    // Add check/checkmate symbol
                    if (isCheckmate) {
                        notation += '#';
                    } else if (isCheck) {
                        notation += '+';
                    }
                    
                    return notation;
                }
                
                // Standard notation
                if (piece.type !== 'pawn') {
                    // Add piece letter for non-pawns (K, Q, R, N, B)
                    notation += piece.type.charAt(0).toUpperCase();
                    
                    // Handle disambiguation
                    // Find all similar pieces that could move to the same destination
                    const similarPieces = [];
                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c < 8; c++) {
                            const boardPiece = board[r][c];
                            if (boardPiece && 
                                boardPiece.type === piece.type && 
                                boardPiece.color === piece.color && 
                                (r !== fromRow || c !== fromCol)) {
                                // Check if this similar piece could move to the same destination
                                const moves = boardPiece.getValidMoves(board);
                                if (moves.some(move => move[0] === toRow && move[1] === toCol)) {
                                    similarPieces.push([r, c]);
                                }
                            }
                        }
                    }
                    
                    // Add disambiguation if necessary
                    if (similarPieces.length > 0) {
                        // Check if file alone is enough
                        if (!similarPieces.some(pos => pos[1] === fromCol)) {
                            // File is unique
                            notation += String.fromCharCode(97 + fromCol);
                        } else if (!similarPieces.some(pos => pos[0] === fromRow)) {
                            // Rank is unique
                            notation += 8 - fromRow;
                        } else {
                            // Both file and rank are needed
                            notation += String.fromCharCode(97 + fromCol) + (8 - fromRow);
                        }
                    }
                }
                
                // Add capture symbol
                if (isCapture) {
                    // If capturing with a pawn, add the file
                    if (piece.type === 'pawn') {
                        notation += String.fromCharCode(97 + fromCol);
                    }
                    notation += 'x';
                }
                
                // Add destination position
                notation += String.fromCharCode(97 + toCol) + (8 - toRow);
                
                // Add promotion piece
                if (isPromotion && promotionPiece) {
                    notation += '=' + promotionPiece.charAt(0).toUpperCase();
                }
                
                // Add check/checkmate symbol
                if (isCheckmate) {
                    notation += '#';
                } else if (isCheck) {
                    notation += '+';
                }
                
                return notation;
            }
            
            function updateNotation(piece, fromRow, fromCol, toRow, toCol, isCapture, isCheck, isCheckmate, isPromotion, promotionPiece, isCastle) {
                const moveNotationText = getNotation(piece, fromRow, fromCol, toRow, toCol, isCapture, isCheck, isCheckmate, isPromotion, promotionPiece, isCastle);
                
                // Important: Use piece.color to determine notation column, not currentPlayer
                // This is because currentPlayer has already been switched when this function is called
                if (piece.color === 'white') {
                    // White piece moved, so add to white column
                    moveNotation.push({ white: moveNotationText, black: '' });
                } else {
                    // Black piece moved, update last entry's black column
                    // Update last entry if it exists
                    if (moveNotation.length > 0) {
                        moveNotation[moveNotation.length - 1].black = moveNotationText;
                    } else {
                        // This should not happen in a normal game, but just in case
                        moveNotation.push({ white: '', black: moveNotationText });
                    }
                }
                
                refreshNotationTable();
            }
            
            function refreshNotationTable() {
                notationBody.innerHTML = '';
                
                moveNotation.forEach((move, index) => {
                    const row = document.createElement('tr');
                    
                    const moveNumberCell = document.createElement('td');
                    moveNumberCell.textContent = index + 1;
                    
                    const whiteCell = document.createElement('td');
                    whiteCell.textContent = move.white;
                    
                    const blackCell = document.createElement('td');
                    blackCell.textContent = move.black;
                    
                    row.appendChild(moveNumberCell);
                    row.appendChild(whiteCell);
                    row.appendChild(blackCell);
                    
                    // Highlight the latest move
                    if (index === moveNotation.length - 1) {
                        // If it's white's turn to move, the last black move should be highlighted
                        // If it's black's turn to move, the last white move should be highlighted
                        if (currentPlayer === 'white' && move.black) {
                            blackCell.classList.add('latest-move');
                        } else if (currentPlayer === 'black' && move.white) {
                            whiteCell.classList.add('latest-move');
                        }
                        
                        // Also highlight newly added empty cells to indicate whose turn it is
                        if (currentPlayer === 'white' && !move.black) {
                            // If white has moved but black hasn't, indicate it's black's turn
                            blackCell.classList.add('current-turn');
                        } else if (currentPlayer === 'black' && !move.white) {
                            // This case is less common but handles if black somehow moved first
                            whiteCell.classList.add('current-turn');
                        }
                    }
                    
                    notationBody.appendChild(row);
                });
                
                // Scroll to bottom to show latest move
                const container = document.querySelector('.notation-table-container');
                container.scrollTop = container.scrollHeight;
            }
            
            // Position Review Functions
            function createMiniBoard(targetElement) {
                targetElement.innerHTML = '';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        const isLight = (row + col) % 2 === 0;
                        square.className = `mini-square ${isLight ? 'light' : 'dark'}`;
                        
                        if (board[row][col]) {
                            const piece = board[row][col];
                            const pieceDiv = document.createElement('div');
                            pieceDiv.className = 'mini-piece';
                            pieceDiv.innerHTML = pieceSVGs[`${piece.color}-${piece.type}`];
                            square.appendChild(pieceDiv);
                        }
                        
                        targetElement.appendChild(square);
                    }
                }
            }
            
            function initializeBoard() {
                // Do not start clock for initial board setup
                if (!gameStarted) {
                    clockRunning = false;
                    if (clockInterval) {
                        clearInterval(clockInterval);
                        clockInterval = null;
                    }
                }
                
                // Reset game state
                currentPlayer = 'white';
                selectedPiece = null;
                validMoves = [];
                gameHistory = [];
                capturedPieces = { white: [], black: [] };
                kings = { white: null, black: null };
                inCheck = { white: false, black: false };
                lastMove = { from: null, to: null };
                waitingForPromotion = null;
                
                // Reset notation
                moveCount = 1;
                moveNotation = [];
                notationBody.innerHTML = '';
                
                // Reset clock
                resetClock();
                
                // Only start the clock if a game has been explicitly started
                updateActiveClockUI();
                if (gameStarted) {
                    console.log("Game is started, starting the clock from initializeBoard");
                    // Force the start of the clock, ensuring it runs regardless of previous state
                    stopClock(); // Stop any existing clock to ensure clean state
                    clockInterval = setInterval(updateClock, 1000);
                    clockRunning = true;
                    console.log("Clock should now be running: " + clockRunning);
                }
                
                // Create an 8x8 empty board
                board = Array(8).fill().map(() => Array(8).fill(null));
                
                // Setup pawns
                for (let col = 0; col < 8; col++) {
                    board[1][col] = new ChessPiece('pawn', 'black', [1, col]);
                    board[6][col] = new ChessPiece('pawn', 'white', [6, col]);
                }
                
                // Setup other pieces
                const setupOrder = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
                
                for (let col = 0; col < 8; col++) {
                    board[0][col] = new ChessPiece(setupOrder[col], 'black', [0, col]);
                    board[7][col] = new ChessPiece(setupOrder[col], 'white', [7, col]);
                    
                    if (setupOrder[col] === 'king') {
                        kings.black = board[0][col];
                        kings.white = board[7][col];
                    }
                }
                
                // Reset game state
                currentPlayer = 'white';
                selectedPiece = null;
                validMoves = [];
                gameHistory = [];
                capturedPieces = { white: [], black: [] };
                inCheck = { white: false, black: false };
                lastMove = { from: null, to: null };
                waitingForPromotion = null;
                
                updateGameStatus();
                renderBoard();
                
                // Update undo button state since there are no moves to undo on a new board
                updateUndoButtonState();
            }
            
            function renderBoard() {
                // Clear the chessboard
                chessboard.innerHTML = '';
                
                // Create the squares and pieces
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
                        
                        // Add chess notation
                        if (col === 0) {
                            const rankNotation = document.createElement('div');
                            rankNotation.className = 'notation rank-notation';
                            rankNotation.textContent = 8 - row;
                            square.appendChild(rankNotation);
                        }
                        
                        if (row === 7) {
                            const fileNotation = document.createElement('div');
                            fileNotation.className = 'notation file-notation';
                            fileNotation.textContent = String.fromCharCode(97 + col);
                            square.appendChild(fileNotation);
                        }
                        
                        // Add highlights for last move
                        if (lastMove.from && lastMove.to) {
                            const [fromRow, fromCol] = lastMove.from;
                            const [toRow, toCol] = lastMove.to;
                            
                            if ((row === fromRow && col === fromCol) || 
                                (row === toRow && col === toCol)) {
                                const highlight = document.createElement('div');
                                highlight.className = 'highlight last-move';
                                square.appendChild(highlight);
                            }
                        }
                        
                        // Highlight checked king
                        const piece = board[row][col];
                        if (piece && piece.type === 'king' && inCheck[piece.color]) {
                            const highlight = document.createElement('div');
                            highlight.className = 'highlight check';
                            square.appendChild(highlight);
                        }
                        
                        // Highlight selected piece
                        if (selectedPiece && row === selectedPiece.position[0] && col === selectedPiece.position[1]) {
                            const highlight = document.createElement('div');
                            highlight.className = 'highlight selected';
                            square.appendChild(highlight);
                        }
                        
                        // Highlight valid moves
                        if (validMoves.some(move => move[0] === row && move[1] === col)) {
                            const highlight = document.createElement('div');
                            highlight.className = 'highlight valid-move';
                            square.appendChild(highlight);
                        }
                        
                        // Add the piece if there is one on this square
                        if (piece) {
                            const pieceElement = document.createElement('div');
                            pieceElement.className = 'piece';
                            pieceElement.innerHTML = pieceSVGs[`${piece.color}-${piece.type}`];
                            pieceElement.dataset.row = row;
                            pieceElement.dataset.col = col;
                            pieceElement.addEventListener('click', handlePieceClick);
                            pieceElement.addEventListener('mousedown', handlePieceMouseDown);
                            pieceElement.addEventListener('touchstart', handlePieceTouchStart, { passive: false });
                            square.appendChild(pieceElement);
                        }
                        
                        // Add click event to the square for moving pieces
                        square.dataset.row = row;
                        square.dataset.col = col;
                        square.addEventListener('click', handleSquareClick);
                        
                        chessboard.appendChild(square);
                    }
                }
                
                // Update the captured pieces display
                renderCapturedPieces();
            }
            
            function renderCapturedPieces() {
                capturedWhite.innerHTML = '';
                capturedBlack.innerHTML = '';
                
                capturedPieces.white.forEach(piece => {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = 'captured-piece';
                    pieceElement.innerHTML = pieceSVGs[`white-${piece}`];
                    capturedWhite.appendChild(pieceElement);
                });
                
                capturedPieces.black.forEach(piece => {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = 'captured-piece';
                    pieceElement.innerHTML = pieceSVGs[`black-${piece}`];
                    capturedBlack.appendChild(pieceElement);
                });
            }
            
            // Variables for drag and drop
            let draggedPiece = null;
            let dragOffsetX = 0;
            let dragOffsetY = 0;
            let originalPosition = null;

            function handlePieceClick(event) {
                const row = parseInt(event.currentTarget.dataset.row);
                const col = parseInt(event.currentTarget.dataset.col);
                const piece = board[row][col];
                
                // Check if it's a computer game and if the current piece belongs to the computer
                if (isComputerGame && piece && piece.color === computerColor) {
                    gameStatus.textContent = "It's the computer's turn. Please wait...";
                    return; // Don't allow selecting computer's pieces
                }
                
                if (piece && piece.color === currentPlayer) {
                    selectedPiece = piece;
                    validMoves = piece.getValidMoves(board);
                    renderBoard();
                }
            }

            function handlePieceMouseDown(event) {
                event.preventDefault();
                const pieceElement = event.target.closest('.piece');
                if (!pieceElement) return;
                
                const row = parseInt(pieceElement.dataset.row);
                const col = parseInt(pieceElement.dataset.col);
                const piece = board[row][col];
                
                // Check if it's a computer game and if the current piece belongs to the computer
                if (isComputerGame && piece && piece.color === computerColor) {
                    gameStatus.textContent = "It's the computer's turn. Please wait...";
                    return; // Don't allow dragging computer's pieces
                }
                
                if (piece && piece.color === currentPlayer) {
                    // Select the piece and show valid moves
                    selectedPiece = piece;
                    validMoves = piece.getValidMoves(board);
                    renderBoard();
                    
                    // Setup for dragging
                    draggedPiece = document.querySelector(`.piece[data-row="${row}"][data-col="${col}"]`);
                    originalPosition = [row, col];
                    
                    // Calculate offset to position piece directly under the cursor
                    const rect = draggedPiece.getBoundingClientRect();
                    dragOffsetX = rect.width / 2;
                    dragOffsetY = rect.height / 2;
                    
                    // Add dragging class and make the piece smaller
                    draggedPiece.classList.add('dragging');
                    draggedPiece.style.transform = 'scale(0.7)';
                    
                    // Update position
                    draggedPiece.style.left = (event.clientX - dragOffsetX) + 'px';
                    draggedPiece.style.top = (event.clientY - dragOffsetY) + 'px';
                    
                    // Add mouse move and mouse up listeners
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                }
            }
            
            function handleMouseMove(event) {
                if (!draggedPiece) return;
                
                event.preventDefault();
                // Use requestAnimationFrame for smoother animation
                requestAnimationFrame(() => {
                    if (draggedPiece) {
                        draggedPiece.style.left = (event.clientX - dragOffsetX) + 'px';
                        draggedPiece.style.top = (event.clientY - dragOffsetY) + 'px';
                    }
                });
            }
            
            function handlePieceTouchStart(event) {
                event.preventDefault();
                const touch = event.touches[0];
                const pieceElement = event.target.closest('.piece');
                if (!pieceElement) return;
                
                const row = parseInt(pieceElement.dataset.row);
                const col = parseInt(pieceElement.dataset.col);
                const piece = board[row][col];
                
                // Check if it's a computer game and if the current piece belongs to the computer
                if (isComputerGame && piece && piece.color === computerColor) {
                    gameStatus.textContent = "It's the computer's turn. Please wait...";
                    return; // Don't allow touching computer's pieces
                }
                
                if (piece && piece.color === currentPlayer) {
                    // Select the piece and show valid moves
                    selectedPiece = piece;
                    validMoves = piece.getValidMoves(board);
                    renderBoard();
                    
                    // Setup for dragging
                    draggedPiece = document.querySelector(`.piece[data-row="${row}"][data-col="${col}"]`);
                    originalPosition = [row, col];
                    
                    // Calculate offset to position piece directly under the touch point
                    const rect = draggedPiece.getBoundingClientRect();
                    dragOffsetX = rect.width / 2;
                    dragOffsetY = rect.height / 2;
                    
                    // Add dragging class and make the piece smaller
                    draggedPiece.classList.add('dragging');
                    draggedPiece.style.transform = 'scale(0.7)';
                    
                    // Update position
                    draggedPiece.style.left = (touch.clientX - dragOffsetX) + 'px';
                    draggedPiece.style.top = (touch.clientY - dragOffsetY) + 'px';
                    
                    // Add touch move and touch end listeners
                    document.addEventListener('touchmove', handleTouchMove, { passive: false });
                    document.addEventListener('touchend', handleTouchEnd);
                    document.addEventListener('touchcancel', handleTouchEnd);
                }
            }
            
            function handleTouchMove(event) {
                if (!draggedPiece) return;
                
                event.preventDefault();
                const touch = event.touches[0];
                
                // Use requestAnimationFrame for smoother touch animation
                requestAnimationFrame(() => {
                    if (draggedPiece) {
                        draggedPiece.style.left = (touch.clientX - dragOffsetX) + 'px';
                        draggedPiece.style.top = (touch.clientY - dragOffsetY) + 'px';
                    }
                });
            }
            
            function handleTouchEnd(event) {
                if (!draggedPiece || !selectedPiece) {
                    cleanupTouch();
                    return;
                }
                
                // Find the square under the touch end point
                const chessboardRect = chessboard.getBoundingClientRect();
                const squareWidth = chessboardRect.width / 8;
                const squareHeight = chessboardRect.height / 8;
                
                const touch = event.changedTouches[0];
                const relX = touch.clientX - chessboardRect.left;
                const relY = touch.clientY - chessboardRect.top;
                
                if (relX < 0 || relY < 0 || relX >= chessboardRect.width || relY >= chessboardRect.height) {
                    // Outside the chessboard, return piece to original position
                    cleanupTouch();
                    return;
                }
                
                const col = Math.floor(relX / squareWidth);
                const row = Math.floor(relY / squareHeight);
                
                // Attempt to move the piece
                makeMove(row, col);
                
                // Clean up
                cleanupTouch();
            }
            
            function cleanupTouch() {
                if (draggedPiece) {
                    // Add a transition when returning to original position
                    draggedPiece.style.transition = 'all 0.2s ease';
                    draggedPiece.style.left = '';
                    draggedPiece.style.top = '';
                    
                    // Remove classes after animation completes
                    setTimeout(() => {
                        if (draggedPiece) {
                            draggedPiece.classList.remove('dragging');
                            draggedPiece.style.transform = ''; // Reset scale
                            draggedPiece.style.transition = '';
                            draggedPiece = null;
                        }
                    }, 200);
                }
                
                document.removeEventListener('touchmove', handleTouchMove);
                document.removeEventListener('touchend', handleTouchEnd);
                document.removeEventListener('touchcancel', handleTouchEnd);
            }
            
            function handleMouseUp(event) {
                if (!draggedPiece || !selectedPiece) {
                    cleanup();
                    return;
                }
                
                event.preventDefault();
                
                // Find the square under the mouse
                const chessboardRect = chessboard.getBoundingClientRect();
                const squareWidth = chessboardRect.width / 8;
                const squareHeight = chessboardRect.height / 8;
                
                const relX = event.clientX - chessboardRect.left;
                const relY = event.clientY - chessboardRect.top;
                
                if (relX < 0 || relY < 0 || relX >= chessboardRect.width || relY >= chessboardRect.height) {
                    // Outside the chessboard, return piece to original position
                    cleanup();
                    return;
                }
                
                const col = Math.floor(relX / squareWidth);
                const row = Math.floor(relY / squareHeight);
                
                // Attempt to move the piece
                makeMove(row, col);
                
                // Clean up
                cleanup();
            }
            
            function cleanup() {
                if (draggedPiece) {
                    // Add a transition when returning to original position
                    draggedPiece.style.transition = 'all 0.2s ease';
                    draggedPiece.style.left = '';
                    draggedPiece.style.top = '';
                    
                    // Remove classes after animation completes
                    setTimeout(() => {
                        if (draggedPiece) {
                            draggedPiece.classList.remove('dragging');
                            draggedPiece.style.transform = ''; // Reset scale
                            draggedPiece.style.transition = '';
                            draggedPiece = null;
                        }
                    }, 200);
                }
                
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            }
            
            function handleSquareClick(event) {
                if (!selectedPiece) return;
                
                const row = parseInt(event.currentTarget.dataset.row);
                const col = parseInt(event.currentTarget.dataset.col);
                
                makeMove(row, col);
            }
            
            function makeMove(row, col) {
                // Check if this is a valid move
                const moveIndex = validMoves.findIndex(move => move[0] === row && move[1] === col);
                
                if (moveIndex !== -1) {
                    const move = validMoves[moveIndex];
                    
                    // If game has started but clock isn't running, start it now
                    if (gameStarted && !clockRunning) {
                        console.log("Starting clock from makeMove");
                        clockInterval = setInterval(updateClock, 1000);
                        clockRunning = true;
                        updateActiveClockUI();
                    }
                    
                    // Save the current state for undo
                    saveGameState();
                    
                    // Get original position for notation
                    const [fromRow, fromCol] = selectedPiece.position;
                    let isCapture = !!board[row][col]; // Check if there's a piece to capture
                    let isPromotion = false;
                    let promotionPiece = null;
                    let isCastle = false;
                    
                    // Handle special move types
                    if (move.length > 2) {
                        isCastle = move[2].startsWith('castle-');
                        isCapture = move[2] === 'en-passant';
                        handleSpecialMove(move, selectedPiece);
                    } else {
                        // Check for pawn promotion
                        if (selectedPiece.type === 'pawn' && 
                            ((selectedPiece.color === 'white' && row === 0) || 
                             (selectedPiece.color === 'black' && row === 7))) {
                            waitingForPromotion = { 
                                from: selectedPiece.position, 
                                to: [row, col],
                                isCapture: isCapture
                            };
                            showPromotionOptions(selectedPiece.color);
                            return;
                        }
                        
                        // Capture piece if there is one
                        if (board[row][col]) {
                            capturedPieces[board[row][col].color].push(board[row][col].type);
                        }
                        
                        // Move the piece
                        lastMove.from = [fromRow, fromCol];
                        lastMove.to = [row, col];
                        
                        board[row][col] = selectedPiece;
                        board[fromRow][fromCol] = null;
                        selectedPiece.position = [row, col];
                        selectedPiece.hasMoved = true;
                    }
                    
                    // Pause clock on the current player
                    if (clockRunning) {
                        stopClock();
                    }
                    
                    // Switch turns
                    currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
                    selectedPiece = null;
                    validMoves = [];
                    
                    // Store the player who just made the move before it gets lost
                    const playerWhoJustMoved = currentPlayer === 'white' ? 'black' : 'white';
                    
                    // Check for check and checkmate
                    console.log("Checking for check and checkmate after move...");
                    updateCheckStatus(); // This will explicitly check for checkmate for both kings and end the game if found
                    updateGameStatus();
                    
                    // Check if the opponent's king is in check
                    const opponentColor = currentPlayer; // Current player is now the opponent
                    const isCheck = inCheck[opponentColor];
                    
                    // Explicitly check for checkmate on the opponent's king
                    const isCheckmate = isCheck && isInCheckmate(opponentColor);
                    
                    console.log(`After ${playerWhoJustMoved}'s move: ${opponentColor} king check status: ${isCheck}, checkmate: ${isCheckmate}`);
                    
                    console.log(`Current player: ${currentPlayer}, isCheck: ${isCheck}, isCheckmate: ${isCheckmate}`);
                    
                    // Add notation of the move to the table
                    // We're updating notation for the player who just made the move (not the current player)
                    const notationPlayer = currentPlayer === 'white' ? 'black' : 'white';
                    const piece = board[row][col]; // The piece that was moved
                    
                    updateNotation(
                        piece, 
                        fromRow, 
                        fromCol, 
                        row, 
                        col, 
                        isCapture, 
                        isCheck, 
                        isCheckmate, 
                        isPromotion, 
                        promotionPiece, 
                        isCastle
                    );
                    
                    // Start the clock for the next player
                    startClock();
                    
                    // Update the undo button state since we've made a move
                    updateUndoButtonState();
                    
                    renderBoard();
                }
            }
            
            function handleSpecialMove(move, piece) {
                const [toRow, toCol, moveType] = move;
                const [fromRow, fromCol] = piece.position;
                
                lastMove.from = [fromRow, fromCol];
                lastMove.to = [toRow, toCol];
                
                switch(moveType) {
                    case 'en-passant':
                        // Capture the pawn that moved next to this one
                        const capturedPawnRow = fromRow;
                        const capturedPawnCol = toCol;
                        capturedPieces[board[capturedPawnRow][capturedPawnCol].color].push('pawn');
                        board[capturedPawnRow][capturedPawnCol] = null;
                        
                        // Move the pawn
                        board[toRow][toCol] = piece;
                        board[fromRow][fromCol] = null;
                        piece.position = [toRow, toCol];
                        piece.hasMoved = true;
                        break;
                        
                    case 'castle-kingside':
                        // Move the king
                        board[toRow][toCol] = piece;
                        board[fromRow][fromCol] = null;
                        piece.position = [toRow, toCol];
                        piece.hasMoved = true;
                        
                        // Move the rook
                        const kingsideRook = board[fromRow][7];
                        board[fromRow][5] = kingsideRook;
                        board[fromRow][7] = null;
                        kingsideRook.position = [fromRow, 5];
                        kingsideRook.hasMoved = true;
                        break;
                        
                    case 'castle-queenside':
                        // Move the king
                        board[toRow][toCol] = piece;
                        board[fromRow][fromCol] = null;
                        piece.position = [toRow, toCol];
                        piece.hasMoved = true;
                        
                        // Move the rook
                        const queensideRook = board[fromRow][0];
                        board[fromRow][3] = queensideRook;
                        board[fromRow][0] = null;
                        queensideRook.position = [fromRow, 3];
                        queensideRook.hasMoved = true;
                        break;
                }
            }
            
            function updateCheckStatus() {
                console.log('Updating check status...');
                
                // Check if either king is in check (only if the king exists and has a valid position)
                if (kings.white && kings.white.position) {
                    inCheck.white = isSquareAttacked(kings.white.position[0], kings.white.position[1], board, 'white');
                    console.log(`White king in check: ${inCheck.white}`);
                }
                
                if (kings.black && kings.black.position) {
                    inCheck.black = isSquareAttacked(kings.black.position[0], kings.black.position[1], board, 'black');
                    console.log(`Black king in check: ${inCheck.black}`);
                }
                
                checkStatus.textContent = '';
                
                // Always check for checkmate for the current player
                // This ensures we check after they've made their move and before they can make another
                const opponentColor = currentPlayer === 'white' ? 'black' : 'white';
                
                // First check if the current player (who just moved) has checkmated the opponent
                if (inCheck[opponentColor]) {
                    const isOpponentCheckmated = isInCheckmate(opponentColor);
                    if (isOpponentCheckmated) {
                        console.log(`${opponentColor.toUpperCase()} IS IN CHECKMATE!`);
                        checkStatus.textContent = `${opponentColor.charAt(0).toUpperCase() + opponentColor.slice(1)} is in Checkmate!`;
                        const winner = opponentColor === 'white' ? 'Black' : 'White';
                        showGameOver(`Checkmate! ${winner} wins the game!`);
                        return; // Stop further evaluation once we know it's checkmate
                    } else {
                        checkStatus.textContent = `${opponentColor.charAt(0).toUpperCase() + opponentColor.slice(1)} is in Check!`;
                    }
                }
                
                // Also check if the current player is in checkmate (though this is less likely)
                if (inCheck[currentPlayer]) {
                    const isCurrentPlayerCheckmated = isInCheckmate(currentPlayer);
                    if (isCurrentPlayerCheckmated) {
                        console.log(`${currentPlayer.toUpperCase()} IS IN CHECKMATE!`);
                        checkStatus.textContent = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)} is in Checkmate!`;
                        const winner = currentPlayer === 'white' ? 'Black' : 'White';
                        showGameOver(`Checkmate! ${winner} wins the game!`);
                        return; // Stop further evaluation once we know it's checkmate
                    } else {
                        checkStatus.textContent = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)} is in Check!`;
                    }
                }
                
                // Check for stalemate only if no one is in checkmate
                if (isStalemate()) {
                    checkStatus.textContent = `Stalemate! Game is a draw.`;
                    showGameOver('Stalemate! The game is a draw.');
                }
            }
            
            function showGameOver(message) {
                // Stop the chess clock when game is over
                stopClock();
                
                gameOverMessage.textContent = message;
                
                // Create a mini version of the final board position
                const finalPositionDiv = document.getElementById('final-position');
                createMiniBoard(finalPositionDiv);
                
                // Show notation summary
                const notationSummary = document.getElementById('notation-summary');
                notationSummary.innerHTML = '';
                
                // Create a simplified version of the notation table
                const table = document.createElement('table');
                table.className = 'mini-notation-table';
                
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                ['#', 'White', 'Black'].forEach(text => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                const tbody = document.createElement('tbody');
                moveNotation.forEach((move, index) => {
                    const row = document.createElement('tr');
                    
                    const moveNumberCell = document.createElement('td');
                    moveNumberCell.textContent = index + 1;
                    
                    const whiteCell = document.createElement('td');
                    whiteCell.textContent = move.white;
                    
                    const blackCell = document.createElement('td');
                    blackCell.textContent = move.black;
                    
                    row.appendChild(moveNumberCell);
                    row.appendChild(whiteCell);
                    row.appendChild(blackCell);
                    
                    tbody.appendChild(row);
                });
                table.appendChild(tbody);
                notationSummary.appendChild(table);
                
                gameOverModal.style.display = 'flex';
            }
            
            function isInCheckmate(color) {
                // First, ensure the king is actually in check
                if (!inCheck[color]) {
                    console.log(`${color} king is not in check, can't be checkmate`);
                    return false;
                }
                
                // Log debug info
                console.log(`Testing checkmate for ${color} king`);
                console.log(`Current player: ${currentPlayer}`);
                
                // Find the king position first
                let kingRow = -1;
                let kingCol = -1;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece && piece.type === 'king' && piece.color === color) {
                            kingRow = row;
                            kingCol = col;
                            break;
                        }
                    }
                    if (kingRow !== -1) break;
                }
                
                if (kingRow === -1) {
                    console.log(`ERROR: ${color} king not found on board`);
                    return false; // This shouldn't happen in a normal game
                }
                
                // Double-check that king is in check
                if (!isSquareAttacked(kingRow, kingCol, board, color)) {
                    console.log(`${color} king at [${kingRow},${kingCol}] is NOT actually in check, fixing internal state`);
                    inCheck[color] = false;
                    return false;
                }
                
                // Check all possible king moves first
                const king = board[kingRow][kingCol];
                const kingMoves = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1],           [0, 1],
                    [1, -1],  [1, 0],  [1, 1]
                ];
                
                console.log(`Verifying all possible king moves for ${color} king at [${kingRow},${kingCol}]:`);
                
                for (const [dr, dc] of kingMoves) {
                    const r = kingRow + dr;
                    const c = kingCol + dc;
                    
                    if (isInBounds(r, c) && (!board[r][c] || board[r][c].color !== color)) {
                        // Create a deep copy of the board for simulation
                        const tempBoard = Array(8).fill().map(() => Array(8).fill(null));
                        for (let i = 0; i < 8; i++) {
                            for (let j = 0; j < 8; j++) {
                                if (board[i][j]) {
                                    tempBoard[i][j] = new ChessPiece(
                                        board[i][j].type,
                                        board[i][j].color,
                                        [...board[i][j].position]
                                    );
                                    tempBoard[i][j].hasMoved = board[i][j].hasMoved;
                                }
                            }
                        }
                        
                        // Move the king on the temporary board
                        tempBoard[r][c] = tempBoard[kingRow][kingCol];
                        tempBoard[kingRow][kingCol] = null;
                        tempBoard[r][c].position = [r, c];
                        
                        // Check if the king is still in check after the move
                        if (!isSquareAttacked(r, c, tempBoard, color)) {
                            console.log(`${color} king can escape to [${r},${c}]`);
                            return false; // King can escape, not checkmate
                        } else {
                            console.log(`${color} king can't escape to [${r},${c}] - square is attacked`);
                        }
                    }
                }
                
                // Now check if any other piece can block or capture
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece && piece.color === color && piece.type !== 'king') {
                            const moves = piece.getValidMoves(board);
                            
                            if (moves.length > 0) {
                                console.log(`${piece.type} at [${row},${col}] can move, not checkmate`);
                                return false;
                            }
                        }
                    }
                }
                
                // If we reach here, no piece can make a valid move to get out of check
                console.log(`CHECKMATE: ${color} king has no legal moves and is in check`);
                return true;
            }
            
            function isStalemate() {
                if (inCheck[currentPlayer]) {
                    return false;
                }
                
                // Check if the current player has any legal moves
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece && piece.color === currentPlayer) {
                            const moves = piece.getValidMoves(board);
                            if (moves.length > 0) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }
            
            function showPromotionOptions(color) {
                const promotionPieceTypes = ['queen', 'rook', 'bishop', 'knight'];
                
                promotionPieces.innerHTML = '';
                
                promotionPieceTypes.forEach(type => {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = 'promotion-piece';
                    pieceElement.innerHTML = pieceSVGs[`${color}-${type}`];
                    pieceElement.dataset.type = type;
                    pieceElement.addEventListener('click', handlePromotionSelection);
                    promotionPieces.appendChild(pieceElement);
                });
                
                promotionModal.style.display = 'flex';
            }
            
            function handlePromotionSelection(event) {
                const pieceType = event.currentTarget.dataset.type;
                
                if (waitingForPromotion) {
                    const [fromRow, fromCol] = waitingForPromotion.from;
                    const [toRow, toCol] = waitingForPromotion.to;
                    const isCapture = waitingForPromotion.isCapture || false;
                    
                    // Pause clock on the current player
                    if (clockRunning) {
                        stopClock();
                    }
                    
                    // Capture piece if there is one
                    if (board[toRow][toCol]) {
                        capturedPieces[board[toRow][toCol].color].push(board[toRow][toCol].type);
                    }
                    
                    // Create the new promoted piece
                    const promotedPiece = new ChessPiece(
                        pieceType, 
                        currentPlayer, 
                        [toRow, toCol]
                    );
                    promotedPiece.hasMoved = true;
                    
                    // Update the board
                    board[toRow][toCol] = promotedPiece;
                    board[fromRow][fromCol] = null;
                    
                    lastMove.from = [fromRow, fromCol];
                    lastMove.to = [toRow, toCol];
                    
                    // Switch turns
                    const notationPlayer = currentPlayer; // Save before switching
                    currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
                    selectedPiece = null;
                    validMoves = [];
                    
                    // Store the player who just made the move
                    const playerWhoJustMoved = currentPlayer === 'white' ? 'black' : 'white'; 
                    
                    // Check for check and checkmate
                    console.log("Checking for check and checkmate after promotion...");
                    updateCheckStatus(); // This will explicitly check for checkmate for both kings
                    updateGameStatus();
                    
                    // Check if the opponent's king is in check
                    const opponentColor = currentPlayer; // Current player is now the opponent
                    const isCheck = inCheck[opponentColor];
                    
                    // Explicitly check for checkmate on the opponent's king
                    const isCheckmate = isCheck && isInCheckmate(opponentColor);
                    
                    console.log(`After ${playerWhoJustMoved}'s promotion: ${opponentColor} king check status: ${isCheck}, checkmate: ${isCheckmate}`);
                    
                    updateNotation(
                        promotedPiece,
                        fromRow,
                        fromCol,
                        toRow,
                        toCol,
                        isCapture,
                        isCheck,
                        isCheckmate,
                        true, // isPromotion
                        pieceType,
                        false // isCastle
                    );
                    
                    // Start the clock for the next player
                    startClock();
                    
                    waitingForPromotion = null;
                    renderBoard();
                }
                
                promotionModal.style.display = 'none';
            }
            
            function saveGameState() {
                const boardCopy = [];
                
                // Deep copy the board
                for (let row = 0; row < 8; row++) {
                    boardCopy[row] = [];
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece) {
                            boardCopy[row][col] = new ChessPiece(
                                piece.type, 
                                piece.color, 
                                [...piece.position]
                            );
                            boardCopy[row][col].hasMoved = piece.hasMoved;
                        } else {
                            boardCopy[row][col] = null;
                        }
                    }
                }
                
                // Deep copy kings
                const kingsCopy = {
                    white: null,
                    black: null
                };
                
                if (kings.white) {
                    const [row, col] = kings.white.position;
                    kingsCopy.white = boardCopy[row][col];
                }
                
                if (kings.black) {
                    const [row, col] = kings.black.position;
                    kingsCopy.black = boardCopy[row][col];
                }
                
                // Deep copy captured pieces
                const capturedPiecesCopy = {
                    white: [...capturedPieces.white],
                    black: [...capturedPieces.black]
                };
                
                // Save game state
                gameHistory.push({
                    board: boardCopy,
                    currentPlayer,
                    kings: kingsCopy,
                    capturedPieces: capturedPiecesCopy,
                    inCheck: { ...inCheck },
                    lastMove: { 
                        from: lastMove.from ? [...lastMove.from] : null,
                        to: lastMove.to ? [...lastMove.to] : null
                    }
                });
                
                // Update undo button state since we now have a move in history
                updateUndoButtonState();
            }
            
            function undoMove() {
                if (gameHistory.length === 0) return;
                
                // Stop the clock
                if (clockRunning) {
                    stopClock();
                }
                
                const lastState = gameHistory.pop();
                
                board = lastState.board;
                currentPlayer = lastState.currentPlayer;
                kings = lastState.kings;
                capturedPieces = lastState.capturedPieces;
                inCheck = lastState.inCheck;
                lastMove = lastState.lastMove;
                
                selectedPiece = null;
                validMoves = [];
                waitingForPromotion = null;
                
                // Undo notation
                if (currentPlayer === 'white') {
                    // If we're back to white, remove the last black move
                    if (moveNotation.length > 0) {
                        // Set the last black move to empty
                        moveNotation[moveNotation.length - 1].black = '';
                        // If both white and black moves are empty, remove the entire row
                        if (moveNotation[moveNotation.length - 1].white === '') {
                            moveNotation.pop();
                        }
                    }
                } else {
                    // If we're undoing to black's turn, remove white's last move
                    if (moveNotation.length > 0) {
                        moveNotation.pop();
                    }
                }
                
                // Update notation display
                refreshNotationTable();
                
                updateGameStatus();
                
                // Update undo button state since we've modified the game history
                updateUndoButtonState();
                
                renderBoard();
                
                // Restart the clock with the current player
                startClock();
            }
            
            function updateGameStatus() {
                if (isStalemate()) {
                    gameStatus.textContent = 'Stalemate! Game is a draw.';
                } else {
                    gameStatus.textContent = `Current Turn: ${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}`;
                }
            }
            
            // Chess Engine functions
            function makeComputerMove() {
                if (!isComputerGame || currentPlayer !== computerColor) {
                    return;
                }
                
                // Update game status to show the computer is thinking
                gameStatus.textContent = `Computer (${computerDifficulty}) is thinking...`;
                
                // Get all available moves for the computer
                const moves = getAllPossibleMoves(board, computerColor);
                
                if (moves.length === 0) {
                    gameStatus.textContent = `Game over. No moves available for ${computerColor}.`;
                    return; // No moves available
                }
                
                // Select a random move as fallback
                const randomIndex = Math.floor(Math.random() * moves.length);
                const randomMove = moves[randomIndex];
                console.log(`Computer selected fallback move: ${randomMove[0].type} from [${randomMove[0].position}] to [${randomMove[1]}]`);
                
                // This is a critical flag to prevent multiple move executions
                let moveExecuted = false;
                
                // Function to safely execute a move with proper board updates
                const executeMove = (moveToExecute) => {
                    // Only execute if we haven't already and it's still computer's turn
                    if (moveExecuted || !isComputerGame || currentPlayer !== computerColor) return;
                    moveExecuted = true;
                    
                    try {
                        // Get piece and target info
                        const piece = moveToExecute[0];
                        const [toRow, toCol] = moveToExecute[1].length > 2 ? 
                            [moveToExecute[1][0], moveToExecute[1][1]] : moveToExecute[1];
                        const specialMove = moveToExecute[1].length > 2 ? moveToExecute[1][2] : null;
                        
                        // Verify the piece still exists at expected position
                        const [fromRow, fromCol] = piece.position;
                        const currentPiece = board[fromRow][fromCol];
                        
                        if (currentPiece && currentPiece.color === computerColor) {
                            // Simple direct move execution for reliability
                            console.log(`Computer is moving ${currentPiece.color} ${currentPiece.type} from [${fromRow},${fromCol}] to [${toRow},${toCol}]`);
                            makeMove(currentPiece, toRow, toCol, specialMove);
                        } else {
                            // Fallback if piece position changed
                            const availablePieces = [];
                            for (let r = 0; r < 8; r++) {
                                for (let c = 0; c < 8; c++) {
                                    if (board[r][c] && board[r][c].color === computerColor) {
                                        const pieceMoves = board[r][c].getValidMoves(board);
                                        if (pieceMoves.length > 0) {
                                            availablePieces.push([board[r][c], pieceMoves[0]]);
                                        }
                                    }
                                }
                            }
                            
                            if (availablePieces.length > 0) {
                                const backupMove = availablePieces[Math.floor(Math.random() * availablePieces.length)];
                                const backupPiece = backupMove[0];
                                const [backupToRow, backupToCol] = backupMove[1].length > 2 ? 
                                    [backupMove[1][0], backupMove[1][1]] : backupMove[1];
                                const backupSpecial = backupMove[1].length > 2 ? backupMove[1][2] : null;
                                
                                console.log(`Computer using backup move: ${backupPiece.type} from [${backupPiece.position}] to [${backupToRow},${backupToCol}]`);
                                makeMove(backupPiece, backupToRow, backupToCol, backupSpecial);
                            }
                        }
                    } catch (error) {
                        // Last resort emergency move
                        try {
                            // Find any valid move on the board
                            for (let r = 0; r < 8; r++) {
                                for (let c = 0; c < 8; c++) {
                                    if (board[r][c] && board[r][c].color === computerColor) {
                                        const pieceMoves = board[r][c].getValidMoves(board);
                                        if (pieceMoves.length > 0) {
                                            const [toRow, toCol] = pieceMoves[0].length > 2 ? 
                                                [pieceMoves[0][0], pieceMoves[0][1]] : pieceMoves[0];
                                            const specialMove = pieceMoves[0].length > 2 ? pieceMoves[0][2] : null;
                                            
                                            console.log(`Computer making emergency move with ${board[r][c].type}`);
                                            makeMove(board[r][c], toRow, toCol, specialMove);
                                            return;
                                        }
                                    }
                                }
                            }
                        } catch (emergencyError) {
                            console.error("Critical failure in computer move system");
                        }
                    }
                };
                
                // Different approaches based on difficulty mode
                if (computerDifficulty === 'easy') {
                    // For easy mode, just make a random move after a delay
                    setTimeout(() => {
                        console.log("Computer (Easy) is making a random move");
                        executeMove(randomMove);
                    }, 1000);
                } else {
                    // For medium mode, calculate the best move with evaluation
                    setTimeout(() => {
                        try {
                            const startTime = Date.now();
                            const timeLimit = 3000; // 3 seconds for calculation
                            
                            console.log("Computer (Medium) is evaluating possible moves...");
                            const bestMove = findBestMove(board, computerColor, 2, startTime, timeLimit);
                            
                            if (bestMove && !moveExecuted && currentPlayer === computerColor) {
                                const scoreInfo = evaluateMove(board, bestMove);
                                console.log(`Computer selected best move: ${bestMove[0].type} with evaluation score: ${scoreInfo}`);
                                executeMove(bestMove);
                            }
                        } catch (error) {
                            console.error("Error in move evaluation, using random move");
                        }
                    }, 100);
                }
                
                // Primary failsafe - guarantee a move after 2-3 seconds
                setTimeout(() => {
                    if (!moveExecuted && currentPlayer === computerColor) {
                        console.log("Computer failsafe: Using random move");
                        executeMove(randomMove);
                    }
                }, computerDifficulty === 'easy' ? 2000 : 3500);
                
                // Ultimate failsafe - absolutely guarantee a move after 5 seconds
                setTimeout(() => {
                    if (!moveExecuted && currentPlayer === computerColor) {
                        console.log("Computer emergency failsafe activated");
                        executeMove(randomMove);
                    }
                }, 5000);
            }
            
            // Helper function to get score info for logging
            function evaluateMove(board, moveToEvaluate) {
                const piece = moveToEvaluate[0];
                const move = moveToEvaluate[1];
                
                // Simulate the move
                const newBoard = simulateMove(board, piece, move);
                
                // Get basic evaluation
                const score = evaluateBoard(newBoard);
                
                return score;
            }
            
            function getAllPossibleMoves(board, color) {
                const moves = [];
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece && piece.color === color) {
                            const pieceMoves = piece.getValidMoves(board);
                            pieceMoves.forEach(move => {
                                moves.push([piece, move]);
                            });
                        }
                    }
                }
                
                return moves;
            }
            
            function evaluateBoard(board) {
                // Piece values: pawn=1, knight=3, bishop=3, rook=5, queen=9, king=100
                const pieceValues = {
                    'pawn': 10,
                    'knight': 30,
                    'bishop': 30,
                    'rook': 50,
                    'queen': 90,
                    'king': 900
                };
                
                // Position bonuses: add small values for controlling center, etc.
                const positionBonuses = {
                    'pawn': [
                        [0, 0, 0, 0, 0, 0, 0, 0],
                        [5, 5, 5, 5, 5, 5, 5, 5],
                        [1, 1, 2, 3, 3, 2, 1, 1],
                        [0.5, 0.5, 1, 2.5, 2.5, 1, 0.5, 0.5],
                        [0, 0, 0, 2, 2, 0, 0, 0],
                        [0.5, -0.5, -1, 0, 0, -1, -0.5, 0.5],
                        [0.5, 1, 1, -2, -2, 1, 1, 0.5],
                        [0, 0, 0, 0, 0, 0, 0, 0]
                    ],
                    'knight': [
                        [-5, -4, -3, -3, -3, -3, -4, -5],
                        [-4, -2, 0, 0, 0, 0, -2, -4],
                        [-3, 0, 1, 1.5, 1.5, 1, 0, -3],
                        [-3, 0.5, 1.5, 2, 2, 1.5, 0.5, -3],
                        [-3, 0, 1.5, 2, 2, 1.5, 0, -3],
                        [-3, 0.5, 1, 1.5, 1.5, 1, 0.5, -3],
                        [-4, -2, 0, 0.5, 0.5, 0, -2, -4],
                        [-5, -4, -3, -3, -3, -3, -4, -5]
                    ],
                    'bishop': [
                        [-2, -1, -1, -1, -1, -1, -1, -2],
                        [-1, 0, 0, 0, 0, 0, 0, -1],
                        [-1, 0, 0.5, 1, 1, 0.5, 0, -1],
                        [-1, 0.5, 0.5, 1, 1, 0.5, 0.5, -1],
                        [-1, 0, 1, 1, 1, 1, 0, -1],
                        [-1, 1, 1, 1, 1, 1, 1, -1],
                        [-1, 0.5, 0, 0, 0, 0, 0.5, -1],
                        [-2, -1, -1, -1, -1, -1, -1, -2]
                    ]
                };
                
                let score = 0;
                
                // Count material and position value
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece) {
                            // Base piece value
                            const value = pieceValues[piece.type];
                            
                            // Position bonus
                            let posBonus = 0;
                            if (positionBonuses[piece.type]) {
                                if (piece.color === 'white') {
                                    posBonus = positionBonuses[piece.type][row][col];
                                } else {
                                    posBonus = positionBonuses[piece.type][7-row][col];
                                }
                            }
                            
                            // Add to score (positive for white, negative for black)
                            const multiplier = piece.color === 'white' ? 1 : -1;
                            score += multiplier * (value + posBonus);
                        }
                    }
                }
                
                return score;
            }
            
            function simulateMove(board, piece, move) {
                // Create a deep copy of the board
                const newBoard = Array(8).fill().map(() => Array(8).fill(null));
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        if (board[i][j]) {
                            newBoard[i][j] = new ChessPiece(
                                board[i][j].type,
                                board[i][j].color,
                                [...board[i][j].position]
                            );
                            newBoard[i][j].hasMoved = board[i][j].hasMoved;
                        }
                    }
                }
                
                // Get positions
                const [fromRow, fromCol] = piece.position;
                const [toRow, toCol] = move.length > 2 ? [move[0], move[1]] : move;
                
                // Execute move on the copy
                if (move.length > 2) {
                    const specialMove = move[2];
                    
                    if (specialMove === 'en-passant') {
                        // Remove the captured pawn
                        newBoard[fromRow][toCol] = null;
                    } else if (specialMove.startsWith('castle-')) {
                        // Move the rook for castling
                        const isKingside = specialMove === 'castle-kingside';
                        const rookCol = isKingside ? 7 : 0;
                        const newRookCol = isKingside ? toCol - 1 : toCol + 1;
                        
                        // Move the rook
                        newBoard[fromRow][newRookCol] = newBoard[fromRow][rookCol];
                        if (newBoard[fromRow][newRookCol]) {
                            newBoard[fromRow][newRookCol].position = [fromRow, newRookCol];
                            newBoard[fromRow][newRookCol].hasMoved = true;
                        }
                        newBoard[fromRow][rookCol] = null;
                    }
                }
                
                // Move the piece
                newBoard[toRow][toCol] = newBoard[fromRow][fromCol];
                if (newBoard[toRow][toCol]) {
                    newBoard[toRow][toCol].position = [toRow, toCol];
                    newBoard[toRow][toCol].hasMoved = true;
                }
                newBoard[fromRow][fromCol] = null;
                
                return newBoard;
            }
            
            function findBestMove(board, color, depth, startTime, timeLimit) {
                const moves = getAllPossibleMoves(board, color);
                
                // If no moves or we're out of time, return null or the best move found so far
                if (moves.length === 0) {
                    return null;
                }
                
                // First, pick a random move as a fallback in case we run out of time
                const randomMove = moves[Math.floor(Math.random() * moves.length)];
                let bestMove = randomMove;
                let bestScore = color === 'white' ? -Infinity : Infinity;
                
                // Only log top-level moves (depth 2)
                const isTopLevel = depth === 2;
                
                // Track the top 3 moves for logging
                let topMoves = [];
                
                for (const [piece, move] of moves) {
                    // Check if we're running out of time (leave 3 seconds as buffer)
                    if (startTime && timeLimit && (Date.now() - startTime > timeLimit - 3000)) {
                        console.log(`Time limit approaching (${Date.now() - startTime}ms), returning best move found so far`);
                        return bestMove;
                    }
                    
                    // Absolute time check - if we're past the time limit, exit immediately
                    if (startTime && timeLimit && (Date.now() - startTime > timeLimit)) {
                        console.log(`CRITICAL: Time limit exceeded (${Date.now() - startTime}ms), must return now`);
                        return bestMove;
                    }
                    
                    // Simulate the move
                    const newBoard = simulateMove(board, piece, move);
                    
                    // Evaluate the position
                    let score;
                    if (depth <= 1) {
                        score = evaluateBoard(newBoard);
                    } else {
                        // Recursively find best move for opponent, passing the time limit
                        const opponentColor = color === 'white' ? 'black' : 'white';
                        const opponentBestMove = findBestMove(newBoard, opponentColor, depth - 1, startTime, timeLimit);
                        
                        // Check if we ran out of time during recursive search
                        if (startTime && timeLimit && (Date.now() - startTime > timeLimit - 2000)) {
                            console.log(`Time limit approaching during recursive search (${Date.now() - startTime}ms)`);
                            return bestMove;
                        }
                        
                        // Absolute time check during recursive search - exit immediately if past limit
                        if (startTime && timeLimit && (Date.now() - startTime >= timeLimit)) {
                            console.log(`CRITICAL: Time limit exceeded during recursive search (${Date.now() - startTime}ms)`);
                            return bestMove;
                        }
                        
                        if (opponentBestMove) {
                            const [opPiece, opMove] = opponentBestMove;
                            const opBoard = simulateMove(newBoard, opPiece, opMove);
                            score = evaluateBoard(opBoard);
                        } else {
                            score = evaluateBoard(newBoard);
                        }
                    }
                    
                    // For top level only, track moves for logging
                    if (isTopLevel) {
                        topMoves.push({
                            piece: piece,
                            move: move,
                            score: score
                        });
                        
                        // Sort and keep only top moves
                        if (color === 'white') {
                            topMoves.sort((a, b) => b.score - a.score);
                        } else {
                            topMoves.sort((a, b) => a.score - b.score);
                        }
                        
                        // Keep only top 3
                        if (topMoves.length > 3) {
                            topMoves = topMoves.slice(0, 3);
                        }
                    }
                    
                    // Update best move if better than current best
                    if (color === 'white' && score > bestScore) {
                        bestScore = score;
                        bestMove = [piece, move];
                    } else if (color === 'black' && score < bestScore) {
                        bestScore = score;
                        bestMove = [piece, move];
                    }
                }
                
                // Log top moves if this is the top level call
                if (isTopLevel && topMoves.length > 0) {
                    console.log(`Top ${topMoves.length} moves for ${color}:`);
                    topMoves.forEach((moveInfo, index) => {
                        console.log(`${index + 1}. ${moveInfo.piece.type} from [${moveInfo.piece.position}] to [${moveInfo.move}] - Score: ${moveInfo.score}`);
                    });
                    console.log(`Selected best move: ${bestMove[0].type} from [${bestMove[0].position}] to [${bestMove[1]}]`);
                }
                
                return bestMove;
            }
            
            // Function to highlight valid moves on the board
            function showValidMoves(moves) {
                moves.forEach(move => {
                    const [row, col] = move.length > 2 ? [move[0], move[1]] : move;
                    const square = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
                    if (square) {
                        const highlight = document.createElement('div');
                        highlight.classList.add('highlight', 'valid-move');
                        square.appendChild(highlight);
                    }
                });
            }
            
            // Function to clear all highlighting on the board
            function clearHighlights() {
                document.querySelectorAll('.highlight').forEach(highlight => {
                    highlight.remove();
                });
                document.querySelectorAll('.square.selected').forEach(square => {
                    square.classList.remove('selected');
                });
            }
            
            function executeMoveWithAnimation(piece, move) {
                // Select the piece first
                selectedPiece = piece;
                validMoves = piece.getValidMoves(board);
                
                // Find the square elements
                const [fromRow, fromCol] = piece.position;
                const fromSquare = document.querySelector(`.square[data-row="${fromRow}"][data-col="${fromCol}"]`);
                if (fromSquare) {
                    fromSquare.classList.add('selected');
                }
                
                // Highlight valid moves
                showValidMoves(validMoves);
                
                // After a short delay, execute the move
                setTimeout(() => {
                    // Execute the move
                    const [toRow, toCol] = move.length > 2 ? [move[0], move[1]] : move;
                    makeMove(selectedPiece, toRow, toCol, move.length > 2 ? move[2] : null);
                    
                    // Reset selections
                    clearHighlights();
                    selectedPiece = null;
                    validMoves = [];
                    
                    // Remove the 'selected' class
                    fromSquare.classList.remove('selected');
                }, 500);
            }
            
            // Event listeners
            resetButton.addEventListener('click', function() {
                // Reset with a stopped clock - don't start a game yet
                gameStarted = false;
                initializeBoard();
                gameOverModal.style.display = 'none';
                isComputerGame = false;
                updateUndoButtonState(); // Update undo button state
            });
            undoButton.addEventListener('click', undoMove);
            newGameBtn.addEventListener('click', function() {
                console.log("New Game button clicked");
                
                // First, reset any game state variables
                gameOverModal.style.display = 'none';
                isComputerGame = false;
                computerColor = 'black'; // Reset computer color to default
                
                // Update computer button to be active since this is a new human game
                updateComputerPlayButton();
                
                // Clear game history to make Undo unavailable
                gameHistory = [];
                updateUndoButtonState();
                
                // Force the clock to start with a completely clean slate
                // This approach directly manages the clock without relying on gameStarted flag
                stopClock(); // Ensure any existing clock is stopped
                
                // Reset the game state - but don't rely on initializeBoard to handle clock
                initializeBoard();
                
                // Update game status to reflect new game
                gameStatus.textContent = "New game started. White's turn to move.";
                
                // After initializing, DIRECTLY force the clock to start
                console.log("Explicitly starting clock for New Game");
                times = { white: INITIAL_TIME, black: INITIAL_TIME }; // Ensure times are reset
                updateClockDisplay();
                clockInterval = setInterval(updateClock, 1000);
                clockRunning = true;
                gameStarted = true; // Ensure flag is properly set
                
                // Make sure UI is updated to show which clock is active
                document.querySelector('.white-clock').classList.add('active');
                document.querySelector('.black-clock').classList.remove('active');
                
                console.log("Clock state: running=" + clockRunning + ", gameStarted=" + gameStarted);
            });
            
            // Add event listener for the Play vs Computer button
            const playComputerBtn = document.getElementById('play-computer');
            const difficultySelect = document.getElementById('computer-difficulty');
            
            // Add event listener for theme selector
            const boardThemeSelect = document.getElementById('board-theme');
            boardThemeSelect.addEventListener('change', function() {
                const themeValue = boardThemeSelect.value;
                
                // Remove all theme classes
                chessboard.classList.remove('classic', 'wood', 'blue', 'green');
                
                // Add the selected theme class
                if (themeValue !== 'classic') {
                    chessboard.classList.add(themeValue);
                }
            });
            
            // Function to update the computer play button state
            function updateComputerPlayButton() {
                if (isComputerGame) {
                    playComputerBtn.disabled = true;
                    playComputerBtn.style.opacity = '0.6';
                    playComputerBtn.style.cursor = 'not-allowed';
                } else {
                    playComputerBtn.disabled = false;
                    playComputerBtn.style.opacity = '1';
                    playComputerBtn.style.cursor = 'pointer';
                }
            }
            
            // Function to update the undo button state based on move history
            function updateUndoButtonState() {
                if (gameHistory.length > 0) {
                    // There are moves to undo
                    undoButton.disabled = false;
                    undoButton.style.opacity = '1';
                    undoButton.style.cursor = 'pointer';
                } else {
                    // No moves to undo
                    undoButton.disabled = true;
                    undoButton.style.opacity = '0.6';
                    undoButton.style.cursor = 'not-allowed';
                }
            }
            
            playComputerBtn.addEventListener('click', function() {
                // If already in a computer game, do nothing
                if (isComputerGame) return;
                
                // If in a human game, switch the current player to computer
                if (gameHistory.length > 0) {
                    isComputerGame = true;
                    computerDifficulty = difficultySelect.value;
                    computerColor = currentPlayer;
                    gameStatus.textContent = `Playing against computer (${computerDifficulty})`;
                    
                    // If it's the computer's turn, make a move
                    if (currentPlayer === computerColor) {
                        setTimeout(makeComputerMove, 1000);
                    }
                } else {
                    // Starting a new game
                    console.log("Starting new computer game");
                    // Set these flags BEFORE calling initializeBoard
                    gameStarted = true; // Set flag to allow clock to start
                    clockNeedsReset = true; // Force clock reset
                    
                    initializeBoard();
                    isComputerGame = true;
                    computerDifficulty = difficultySelect.value;
                    computerColor = 'black'; // Default to computer playing as black
                    gameStatus.textContent = `Playing against computer (${computerDifficulty})`;
                    
                    // Clock is started in initializeBoard since gameStarted flag is true
                    console.log("After computer game initializeBoard - clockRunning: " + clockRunning);
                    
                    // Extra safety - directly start the clock if it's not already running
                    if (!clockRunning) {
                        console.log("Forcing clock to start after Computer Game");
                        clockInterval = setInterval(updateClock, 1000);
                        clockRunning = true;
                        updateActiveClockUI();
                    }
                }
                
                // Update button state
                updateComputerPlayButton();
            });
            
            // Update the makeMove function to handle computer response
            const originalMakeMove = makeMove;
            makeMove = function(piece, row, col, specialMove) {
                originalMakeMove(piece, row, col, specialMove);
                
                // If it's now the computer's turn, make a move after a short delay
                if (isComputerGame && currentPlayer === computerColor) {
                    setTimeout(makeComputerMove, 1000);
                }
            };
            
            // The resetButton listener is already defined above
            
            // Initialize the game
            gameStarted = false; // Ensure the clock doesn't start on initial board setup
            initializeBoard();
            updateComputerPlayButton();
            updateUndoButtonState(); // Initialize undo button state
        });
    </script>
</body>
</html>